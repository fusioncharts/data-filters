(function(window, document, undefined) {
"use strict";

class FCDataFilterExt {
  constructor (datastore, userconfig, id, cb) {
    /**
    * User configuration format
    * {
    *   hideControl: false,
    *   dynamicControl: false,
    *   blockedCategories: ['Product'],
    *   disabledCategories: ['Product'],
    *   disabledItems: {
    *     'Product' : ['Tea']
    *   },
    *   range: {
    *     year: {min: 2000, max: 2010, step: 3, precision: 2}
    *   }
    * }
    */
    this.multiChart = new MultiCharting();
    this.datastore = datastore;
    this.callback = cb;
    this.userconfig = userconfig || {};
    this.displayConfig = this.createMenuConfigFromData();
    this.filterVisual = new FilterVisual(this.displayConfig, id, this);
    // data set
  }

  generateBlockList (_list) {
    var list = _list || [],
      i = 0,
      ii = list.length,
      key,
      includeAll = false,
      blockList = [],
      item = {},
      itemListArr = [],
      j = 0,
      jj = 0,
      min = 0,
      max = 0,
      subItem = {};
    for (i = 0; i < ii; ++i) {
      item = list[i];
      includeAll = false;
      // if config was disabled or not visible; skip
      if (item.disabled || !item.visible) {
        continue;
      }
      if (!item.checked) {
        includeAll = true;
      }
      // Operation for type string
      if (item.type === 'string') {
        for (j = 0, jj = item.items.length; j < jj; ++j) {
          subItem = item.items[j];
          if (!subItem.disabled && (includeAll || !subItem.checked)) {
            if (blockList.indexOf(item.category + subItem.value) === -1) {
              blockList.push(item.category + subItem.value);
            } // end if
          } // end if
        } // end for j
      } // end if
      // operation for type number
      if (item.type === 'number') {
        for (j = 0, jj = item.items.length; j < jj; ++j) {
          subItem = item.items[j];
          min = item.range[0];
          max = item.range[1];
          if (includeAll || subItem.value < min || subItem.value > max) {
            if (blockList.indexOf(item.category + subItem.value) === -1) {
              blockList.push(item.category + subItem.value);
            } // end if
          } // end if
        } // end for j
      } // end if
    } // end for i
    return blockList;
  } // end function

  /**
  * function that will be called after
  * apply has been clicked in ui
  */
  apply (config) {
    var dataprocessor = this.multiChart.createDataProcessor(),
      datastore = this.multiChart.createDataStore();
    dataprocessor.filter(this.createFilter(config));
    // Executing the callback function whenever filter is applied
    this.callback(this.datastore.getData(dataprocessor));
  }

  createFilter (_config) {
    var config = _config || this.displayConfig,
      blockList = this.generateBlockList(config);
    return function (object, index, array) {
      var key;
      for (key in object) {
        if (blockList.indexOf(key + object[key]) !== -1) {
          return;
        }
      }
      return object;
    };
  }

  /**
  * Create config menu according to which
  * view will be rendered.
  */
  createMenuConfigFromData () {
    var configOb = {
        visible: !this.hideControl,
        dynamic: !!this.dynamicControl,
        data: []
      },
      config = configOb.data,
      datastore = this.datastore,
      key = '',
      temp = {},
      tempArr = {},
      type = '',
      keysArr = datastore.getKeys(),
      i = 0,
      ii = 0;
    if (!datastore) {
      return;
    }
    // Iterating over unique keys
    for (i = 0, ii = keysArr.length; i < ii; ++i) {
      key = keysArr[i];
      temp = {
        category: key,
        visible: true
      };
      this.__createItemsList__(temp);
      this.__applyUserConfig__(temp);
      config.push(temp);
    }
    return config;
  }

  __createItemsList__ (object) {
    var datastore = this.datastore,
      category = object.category,
      valuesArr = datastore.getUniqueValues(category),
      type = this.__getType__(valuesArr, category),
      min = 0,
      max = 0,
      i = 0,
      ii = 0,
      step = 0,
      precision = 0;
    // setting type
    object.type = type;
    if (type === 'string') {
      // string will have items list
      object.items = [];
      for (i = 0, ii = valuesArr.length; i < ii; ++i) {
        object.items.push({
          value: valuesArr[i],
          disabled: false,
          checked: true
        });
      }
    } else if (type === 'number') {
      // numbers will have range and a value list
      object.items = [];
      for (i = 0, ii = valuesArr.length; i < ii; ++i) {
        object.items.push({
          value: valuesArr[i]
        });
      }
      min = Math.min.apply(null, valuesArr);
      max = Math.max.apply(null, valuesArr);
      if (this.userconfig.range && this.userconfig.range[category]) {
        if (this.userconfig.range[category].min && this.userconfig.range[category].min > min) {
          min = this.userconfig.range[category].min;
        }
        if (this.userconfig.range[category].max && this.userconfig.range[category].max < max) {
          max = this.userconfig.range[category].max;
        }
        step = this.userconfig[category].step || 0;
        precision = this.userconfig[category].precision || 2;
      }
      object.range = {
        min: min,
        max: max,
        step: step,
        precision: precision
      };
    }
  }

  __applyUserConfig__ (object) {
    var userconfig = this.userconfig,
      type = object.type,
      category = object.category,
      blockedCategories = userconfig.blockedCategories,
      disabledCategories = userconfig.disabledCategories,
      disabledItems = userconfig.disabledItems && userconfig.disabledItems[category],
      items = object.items || [],
      i = 0,
      ii = items.length;

    if (Array.isArray(blockedCategories) && blockedCategories.indexOf(category) !== -1) {
      object.visible = false;
    }
    if (Array.isArray(disabledCategories) && disabledCategories.indexOf(category) !== -1) {
      object.disabled = true;
    }

    if (Array.isArray(disabledItems)) {
      for (; i < ii; ++i) {
        if (disabledItems.indexOf(items[i].value) !== -1) {
          object.items[i].disabled = true;
        }
      }
    }
  }

  __getType__ (arr, category) {
    let i = arr.length,
      userconfig = this.userconfig,
      type = {
        string: 'string',
        number: 'number'
      };
    while (i--) {
      if (isNaN(+arr[i])) {
        return type.string;
      }
    }
    if (!userconfig.range || !userconfig.range[category]) {
      return type.string;
    }
    return type.number;
  }
}
window.FCDataFilterExt = FCDataFilterExt;

'use strict';

class FilterVisual {

  constructor (filterState, containerId, filterExt) {
    /**
     * @private
     */
    this.filterState = filterState;
    this.originalFilterState = this.makeCopy(filterState);
    this.filterExt = filterExt;
    this.config = {};
    this.config.containerId = containerId;
    this.draw();
  }

  /**
   * @private
   * Make copy of array of Objects
   */
  makeCopy (arrayOfObjects) {
    var i,
      copy = [];

    for (i = 0; i < arrayOfObjects.length; i++) {
      copy.push(JSON.parse(JSON.stringify(arrayOfObjects[i])));
    }
    return copy;
  }

  /**
   * @private
   * Create DOM elements and set attributes
   */
  createElements (name, attr) {
    var elem = document.createElement(name),
      key;

    for (key in attr) {
      elem.setAttribute(key, attr[key]);
    }

    return elem;
  }

  /**
   * @private
   * Create range slider component
   */
  createSlider (parentElement, dataObj) {
    var self = this,
      sliderWrapper,
      inputWrapper,
      minInput,
      maxInput,
      sliderBase,
      sliderConnect,
      minSliderHandle,
      maxSliderHandle,
      range = dataObj.range,
      minVal = range[0],
      maxVal = range[1],
      diffVal = maxVal - minVal,
      getInputValue = function () {
        var sliderBaseWidth = sliderBase.offsetWidth,
          valuePerPixel = diffVal / sliderBaseWidth;
        return {
          min: Math.round((valuePerPixel * parseInt(minSliderHandle.style.left)) + minVal),
          max: Math.round((valuePerPixel * parseInt(maxSliderHandle.style.left)) + minVal)
        };
      },
      // Attach events to range slider handles
      attachHandlerEvent = function (elem, type) {
        var initX,
          mousePressX,
          flag = true,
          rangeObj,
          callBack = (event) => {
            var element = this;
            if (flag) {
              setTimeout(() => {
                flag = false;
                repositionElement.call(element, event);
              }, 100);
            }
          },

          // Set style to slider handle to reposition along drag
          repositionElement = (event) => {
            var sliderBaseWidth = sliderBase.offsetWidth,
              left = parseInt(initX) + event.clientX - mousePressX,
              min,
              max;

            if (type === 'min') {
              min = 0;
              max = parseInt(maxSliderHandle.style.left) - 10;
            } else {
              min = parseInt(minSliderHandle.style.left) + 10;
              max = sliderBaseWidth;
            }

            if (left >= min && left <= max) {
              elem.style.left = left + 'px';
              if (type === 'min') {
                sliderConnect.style.left = left + 'px';
              } else {
                sliderConnect.style.right = (sliderBaseWidth - left) + 'px';
              }
              rangeObj = getInputValue();
              dataObj.range[0] = minInput.value = rangeObj.min;
              dataObj.range[1] = maxInput.value = rangeObj.max;
            }
            flag = true;
          };

        elem.addEventListener('mousedown', function (evnt) {
          var mouseUpCallBack = function () {
            self.applyFilter();
            window.removeEventListener('mousemove', callBack, false);
            window.removeEventListener('mouseup', mouseUpCallBack, false);
          };
          initX = elem.style.left;
          mousePressX = evnt.clientX;
          window.addEventListener('mousemove', callBack, false);
          window.addEventListener('mouseup', mouseUpCallBack, false);
        }, false);
      },

      // Attach event to min max input text field of range slider
      attachInputEvent = function (elem, type) {
        elem.addEventListener('blur', function (evnt) {
          var sliderBaseWidth = sliderBase.offsetWidth,
            pixelPerValue = sliderBaseWidth / diffVal,
            minInputVal = Number(minInput.value),
            maxInputVal = Number(maxInput.value),
            tempVal,
            rangeObj;

          if ((minInputVal >= minVal) && (maxInputVal <= maxVal) && (minInputVal <= maxInputVal)) {
            sliderConnect.style.left = minSliderHandle.style.left =
              Math.round((pixelPerValue * (minInputVal - minVal))) + 'px';
            tempVal = Math.round(pixelPerValue * (maxInputVal - minVal));
            maxSliderHandle.style.left = tempVal + 'px';
            sliderConnect.style.right = (sliderBaseWidth - tempVal) + 'px';
          }
          rangeObj = getInputValue();
          dataObj.range[0] = minInput.value = rangeObj.min;
          dataObj.range[1] = maxInput.value = rangeObj.max;
          self.applyFilter();
        }, false);
      };

    // Create slider elements
    sliderWrapper = self.createElements('div', {
      'class': 'fc_ext_filter_slider_wrapper'
    });
    parentElement.appendChild(sliderWrapper);

    inputWrapper = self.createElements('div', {
      'class': 'fc_ext_filter_slider_input'
    });
    sliderWrapper.appendChild(inputWrapper);

    minInput = self.createElements('input', {
      'type': 'text',
      'value': minVal
    });
    inputWrapper.appendChild(minInput);
    attachInputEvent(minInput, 'min');

    maxInput = self.createElements('input', {
      'type': 'text',
      'value': maxVal,
      'style': 'float: right;'
    });
    inputWrapper.appendChild(maxInput);
    attachInputEvent(maxInput, 'max');

    sliderBase = self.createElements('div', {
      'class': 'fc_ext_filter_slider_base'
    });
    sliderWrapper.appendChild(sliderBase);

    sliderConnect = self.createElements('div', {
      'class': 'fc_ext_filter_slider_connect',
      'style': 'left: 0px; right: 0px;'
    });
    sliderBase.appendChild(sliderConnect);

    minSliderHandle = self.createElements('div', {
      'class': 'fc_ext_filter_slider_handle',
      'style': 'left: 0px;'
    });
    sliderBase.appendChild(minSliderHandle);
    attachHandlerEvent(minSliderHandle, 'min');

    maxSliderHandle = self.createElements('div', {
      'class': 'fc_ext_filter_slider_handle',
      'style': 'left:' + sliderBase.offsetWidth + 'px'
    });
    sliderBase.appendChild(maxSliderHandle);
    attachHandlerEvent(maxSliderHandle, 'max');
  }

  /**
   * @private
   * Draw the filter component
   */
  draw () {
    var self = this,
      filterState = self.filterState,
      containerId = self.config.containerId,
      parentContainer = document.getElementById(containerId),
      wrapper,
      section,
      cards,
      header,
      label,
      cardBody,
      ul,
      li,
      i,
      j,
      button;

    if (!parentContainer) {
      return;
    }

    parentContainer.innerHTML = '';

    wrapper = self.createElements('div', {
      'class': 'fc_ext_filter_cont',
      'style': 'overflow-y: scroll; overflow-x: hidden;'
    });
    wrapper.style.height = parentContainer.style.height;
    parentContainer.appendChild(wrapper);

    for (i = 0; i < filterState.length; i++) {
      let catObj = filterState[i],
        input,
        catName = catObj.category;

      if (catObj.visible) {
        section = self.createElements('section');
        wrapper.appendChild(section);

        cards = self.createElements('div', {
          'class': 'fc_ext_filter_card'
        });
        section.appendChild(cards);

        header = self.createElements('header');
        cards.appendChild(header);

        label = self.createElements('label');
        label.innerHTML = catName.toUpperCase();
        header.appendChild(label);

        cardBody = self.createElements('div', {
          'class': 'fc_ext_filter_card-body'
        });
        cards.appendChild(cardBody);

        if (catObj.type === 'string') {
          ul = self.createElements('ul');
          cardBody.appendChild(ul);

          for (j = 0; j < catObj.items.length; j++) {
            let itemObj = catObj.items[j],
              input,
              itemVal = itemObj.value;

            li = self.createElements('li');
            ul.appendChild(li);

            input = self.createElements('input', {
              'type': 'checkbox',
              'value': itemVal,
              'id': 'fc_ext_filter_item_' + itemVal,
              'checked': itemObj.checked,
              'style': 'cursor: pointer;'
            });
            input.addEventListener('change', function () {
              itemObj.checked = input.checked;
              self.applyFilter();
            }, false);

            itemObj.elem = input;
            input.disabled = itemObj.disabled;
            li.appendChild(input);
            label = self.createElements('label', {
              'for': 'fc_ext_filter_item_' + itemVal,
              'style': 'cursor: pointer;'
            });
            label.innerHTML = itemVal.toUpperCase();
            li.appendChild(label);
          }
        } else {
          self.createSlider(cardBody, catObj);
        }
      }
    }
    section = self.createElements('section');
    wrapper.appendChild(section);
    button = self.createElements('button');
    button.innerHTML = 'Reset';
    button.onclick = function () {
      self.filterState = self.makeCopy(self.originalFilterState);
      self.draw();
      self.applyFilter();
    };
    section.appendChild(button);
    window.filterState = filterState;
    window.originalFilterState = self.originalFilterState;
  }

  // Apply filter to the Data
  applyFilter () {
    var self = this;
    self.filterExt.apply(self.filterState);
  }
}
}(this, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJkYXRhLWZpbHRlci1lczYubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblwidXNlIHN0cmljdFwiO1xuXG5jbGFzcyBGQ0RhdGFGaWx0ZXJFeHQge1xuICBjb25zdHJ1Y3RvciAoZGF0YXN0b3JlLCB1c2VyY29uZmlnLCBpZCwgY2IpIHtcbiAgICAvKipcbiAgICAqIFVzZXIgY29uZmlndXJhdGlvbiBmb3JtYXRcbiAgICAqIHtcbiAgICAqICAgaGlkZUNvbnRyb2w6IGZhbHNlLFxuICAgICogICBkeW5hbWljQ29udHJvbDogZmFsc2UsXG4gICAgKiAgIGJsb2NrZWRDYXRlZ29yaWVzOiBbJ1Byb2R1Y3QnXSxcbiAgICAqICAgZGlzYWJsZWRDYXRlZ29yaWVzOiBbJ1Byb2R1Y3QnXSxcbiAgICAqICAgZGlzYWJsZWRJdGVtczoge1xuICAgICogICAgICdQcm9kdWN0JyA6IFsnVGVhJ11cbiAgICAqICAgfSxcbiAgICAqICAgcmFuZ2U6IHtcbiAgICAqICAgICB5ZWFyOiB7bWluOiAyMDAwLCBtYXg6IDIwMTAsIHN0ZXA6IDMsIHByZWNpc2lvbjogMn1cbiAgICAqICAgfVxuICAgICogfVxuICAgICovXG4gICAgdGhpcy5tdWx0aUNoYXJ0ID0gbmV3IE11bHRpQ2hhcnRpbmcoKTtcbiAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gICAgdGhpcy51c2VyY29uZmlnID0gdXNlcmNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmRpc3BsYXlDb25maWcgPSB0aGlzLmNyZWF0ZU1lbnVDb25maWdGcm9tRGF0YSgpO1xuICAgIHRoaXMuZmlsdGVyVmlzdWFsID0gbmV3IEZpbHRlclZpc3VhbCh0aGlzLmRpc3BsYXlDb25maWcsIGlkLCB0aGlzKTtcbiAgICAvLyBkYXRhIHNldFxuICB9XG5cbiAgZ2VuZXJhdGVCbG9ja0xpc3QgKF9saXN0KSB7XG4gICAgdmFyIGxpc3QgPSBfbGlzdCB8fCBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSBsaXN0Lmxlbmd0aCxcbiAgICAgIGtleSxcbiAgICAgIGluY2x1ZGVBbGwgPSBmYWxzZSxcbiAgICAgIGJsb2NrTGlzdCA9IFtdLFxuICAgICAgaXRlbSA9IHt9LFxuICAgICAgaXRlbUxpc3RBcnIgPSBbXSxcbiAgICAgIGogPSAwLFxuICAgICAgamogPSAwLFxuICAgICAgbWluID0gMCxcbiAgICAgIG1heCA9IDAsXG4gICAgICBzdWJJdGVtID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgaW5jbHVkZUFsbCA9IGZhbHNlO1xuICAgICAgLy8gaWYgY29uZmlnIHdhcyBkaXNhYmxlZCBvciBub3QgdmlzaWJsZTsgc2tpcFxuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQgfHwgIWl0ZW0udmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbS5jaGVja2VkKSB7XG4gICAgICAgIGluY2x1ZGVBbGwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gT3BlcmF0aW9uIGZvciB0eXBlIHN0cmluZ1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBpdGVtLml0ZW1zLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBzdWJJdGVtID0gaXRlbS5pdGVtc1tqXTtcbiAgICAgICAgICBpZiAoIXN1Ykl0ZW0uZGlzYWJsZWQgJiYgKGluY2x1ZGVBbGwgfHwgIXN1Ykl0ZW0uY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIGlmIChibG9ja0xpc3QuaW5kZXhPZihpdGVtLmNhdGVnb3J5ICsgc3ViSXRlbS52YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGJsb2NrTGlzdC5wdXNoKGl0ZW0uY2F0ZWdvcnkgKyBzdWJJdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH0gLy8gZW5kIGlmXG4gICAgICAgICAgfSAvLyBlbmQgaWZcbiAgICAgICAgfSAvLyBlbmQgZm9yIGpcbiAgICAgIH0gLy8gZW5kIGlmXG4gICAgICAvLyBvcGVyYXRpb24gZm9yIHR5cGUgbnVtYmVyXG4gICAgICBpZiAoaXRlbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGl0ZW0uaXRlbXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIHN1Ykl0ZW0gPSBpdGVtLml0ZW1zW2pdO1xuICAgICAgICAgIG1pbiA9IGl0ZW0ucmFuZ2VbMF07XG4gICAgICAgICAgbWF4ID0gaXRlbS5yYW5nZVsxXTtcbiAgICAgICAgICBpZiAoaW5jbHVkZUFsbCB8fCBzdWJJdGVtLnZhbHVlIDwgbWluIHx8IHN1Ykl0ZW0udmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIGlmIChibG9ja0xpc3QuaW5kZXhPZihpdGVtLmNhdGVnb3J5ICsgc3ViSXRlbS52YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGJsb2NrTGlzdC5wdXNoKGl0ZW0uY2F0ZWdvcnkgKyBzdWJJdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH0gLy8gZW5kIGlmXG4gICAgICAgICAgfSAvLyBlbmQgaWZcbiAgICAgICAgfSAvLyBlbmQgZm9yIGpcbiAgICAgIH0gLy8gZW5kIGlmXG4gICAgfSAvLyBlbmQgZm9yIGlcbiAgICByZXR1cm4gYmxvY2tMaXN0O1xuICB9IC8vIGVuZCBmdW5jdGlvblxuXG4gIC8qKlxuICAqIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXJcbiAgKiBhcHBseSBoYXMgYmVlbiBjbGlja2VkIGluIHVpXG4gICovXG4gIGFwcGx5IChjb25maWcpIHtcbiAgICB2YXIgZGF0YXByb2Nlc3NvciA9IHRoaXMubXVsdGlDaGFydC5jcmVhdGVEYXRhUHJvY2Vzc29yKCksXG4gICAgICBkYXRhc3RvcmUgPSB0aGlzLm11bHRpQ2hhcnQuY3JlYXRlRGF0YVN0b3JlKCk7XG4gICAgZGF0YXByb2Nlc3Nvci5maWx0ZXIodGhpcy5jcmVhdGVGaWx0ZXIoY29uZmlnKSk7XG4gICAgLy8gRXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuZXZlciBmaWx0ZXIgaXMgYXBwbGllZFxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5kYXRhc3RvcmUuZ2V0RGF0YShkYXRhcHJvY2Vzc29yKSk7XG4gIH1cblxuICBjcmVhdGVGaWx0ZXIgKF9jb25maWcpIHtcbiAgICB2YXIgY29uZmlnID0gX2NvbmZpZyB8fCB0aGlzLmRpc3BsYXlDb25maWcsXG4gICAgICBibG9ja0xpc3QgPSB0aGlzLmdlbmVyYXRlQmxvY2tMaXN0KGNvbmZpZyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCBhcnJheSkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoYmxvY2tMaXN0LmluZGV4T2Yoa2V5ICsgb2JqZWN0W2tleV0pICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGNvbmZpZyBtZW51IGFjY29yZGluZyB0byB3aGljaFxuICAqIHZpZXcgd2lsbCBiZSByZW5kZXJlZC5cbiAgKi9cbiAgY3JlYXRlTWVudUNvbmZpZ0Zyb21EYXRhICgpIHtcbiAgICB2YXIgY29uZmlnT2IgPSB7XG4gICAgICAgIHZpc2libGU6ICF0aGlzLmhpZGVDb250cm9sLFxuICAgICAgICBkeW5hbWljOiAhIXRoaXMuZHluYW1pY0NvbnRyb2wsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgICB9LFxuICAgICAgY29uZmlnID0gY29uZmlnT2IuZGF0YSxcbiAgICAgIGRhdGFzdG9yZSA9IHRoaXMuZGF0YXN0b3JlLFxuICAgICAga2V5ID0gJycsXG4gICAgICB0ZW1wID0ge30sXG4gICAgICB0ZW1wQXJyID0ge30sXG4gICAgICB0eXBlID0gJycsXG4gICAgICBrZXlzQXJyID0gZGF0YXN0b3JlLmdldEtleXMoKSxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSAwO1xuICAgIGlmICghZGF0YXN0b3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEl0ZXJhdGluZyBvdmVyIHVuaXF1ZSBrZXlzXG4gICAgZm9yIChpID0gMCwgaWkgPSBrZXlzQXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGtleSA9IGtleXNBcnJbaV07XG4gICAgICB0ZW1wID0ge1xuICAgICAgICBjYXRlZ29yeToga2V5LFxuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9O1xuICAgICAgdGhpcy5fX2NyZWF0ZUl0ZW1zTGlzdF9fKHRlbXApO1xuICAgICAgdGhpcy5fX2FwcGx5VXNlckNvbmZpZ19fKHRlbXApO1xuICAgICAgY29uZmlnLnB1c2godGVtcCk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfX2NyZWF0ZUl0ZW1zTGlzdF9fIChvYmplY3QpIHtcbiAgICB2YXIgZGF0YXN0b3JlID0gdGhpcy5kYXRhc3RvcmUsXG4gICAgICBjYXRlZ29yeSA9IG9iamVjdC5jYXRlZ29yeSxcbiAgICAgIHZhbHVlc0FyciA9IGRhdGFzdG9yZS5nZXRVbmlxdWVWYWx1ZXMoY2F0ZWdvcnkpLFxuICAgICAgdHlwZSA9IHRoaXMuX19nZXRUeXBlX18odmFsdWVzQXJyLCBjYXRlZ29yeSksXG4gICAgICBtaW4gPSAwLFxuICAgICAgbWF4ID0gMCxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSAwLFxuICAgICAgc3RlcCA9IDAsXG4gICAgICBwcmVjaXNpb24gPSAwO1xuICAgIC8vIHNldHRpbmcgdHlwZVxuICAgIG9iamVjdC50eXBlID0gdHlwZTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHN0cmluZyB3aWxsIGhhdmUgaXRlbXMgbGlzdFxuICAgICAgb2JqZWN0Lml0ZW1zID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHZhbHVlc0Fyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIG9iamVjdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVzQXJyW2ldLFxuICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICBjaGVja2VkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIG51bWJlcnMgd2lsbCBoYXZlIHJhbmdlIGFuZCBhIHZhbHVlIGxpc3RcbiAgICAgIG9iamVjdC5pdGVtcyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSB2YWx1ZXNBcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBvYmplY3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlc0FycltpXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHZhbHVlc0Fycik7XG4gICAgICBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB2YWx1ZXNBcnIpO1xuICAgICAgaWYgKHRoaXMudXNlcmNvbmZpZy5yYW5nZSAmJiB0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldLm1pbiAmJiB0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldLm1pbiA+IG1pbikge1xuICAgICAgICAgIG1pbiA9IHRoaXMudXNlcmNvbmZpZy5yYW5nZVtjYXRlZ29yeV0ubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldLm1heCAmJiB0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldLm1heCA8IG1heCkge1xuICAgICAgICAgIG1heCA9IHRoaXMudXNlcmNvbmZpZy5yYW5nZVtjYXRlZ29yeV0ubWF4O1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSB0aGlzLnVzZXJjb25maWdbY2F0ZWdvcnldLnN0ZXAgfHwgMDtcbiAgICAgICAgcHJlY2lzaW9uID0gdGhpcy51c2VyY29uZmlnW2NhdGVnb3J5XS5wcmVjaXNpb24gfHwgMjtcbiAgICAgIH1cbiAgICAgIG9iamVjdC5yYW5nZSA9IHtcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvblxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfX2FwcGx5VXNlckNvbmZpZ19fIChvYmplY3QpIHtcbiAgICB2YXIgdXNlcmNvbmZpZyA9IHRoaXMudXNlcmNvbmZpZyxcbiAgICAgIHR5cGUgPSBvYmplY3QudHlwZSxcbiAgICAgIGNhdGVnb3J5ID0gb2JqZWN0LmNhdGVnb3J5LFxuICAgICAgYmxvY2tlZENhdGVnb3JpZXMgPSB1c2VyY29uZmlnLmJsb2NrZWRDYXRlZ29yaWVzLFxuICAgICAgZGlzYWJsZWRDYXRlZ29yaWVzID0gdXNlcmNvbmZpZy5kaXNhYmxlZENhdGVnb3JpZXMsXG4gICAgICBkaXNhYmxlZEl0ZW1zID0gdXNlcmNvbmZpZy5kaXNhYmxlZEl0ZW1zICYmIHVzZXJjb25maWcuZGlzYWJsZWRJdGVtc1tjYXRlZ29yeV0sXG4gICAgICBpdGVtcyA9IG9iamVjdC5pdGVtcyB8fCBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9ja2VkQ2F0ZWdvcmllcykgJiYgYmxvY2tlZENhdGVnb3JpZXMuaW5kZXhPZihjYXRlZ29yeSkgIT09IC0xKSB7XG4gICAgICBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNhYmxlZENhdGVnb3JpZXMpICYmIGRpc2FibGVkQ2F0ZWdvcmllcy5pbmRleE9mKGNhdGVnb3J5KSAhPT0gLTEpIHtcbiAgICAgIG9iamVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGlzYWJsZWRJdGVtcykpIHtcbiAgICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAoZGlzYWJsZWRJdGVtcy5pbmRleE9mKGl0ZW1zW2ldLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICBvYmplY3QuaXRlbXNbaV0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX19nZXRUeXBlX18gKGFyciwgY2F0ZWdvcnkpIHtcbiAgICBsZXQgaSA9IGFyci5sZW5ndGgsXG4gICAgICB1c2VyY29uZmlnID0gdGhpcy51c2VyY29uZmlnLFxuICAgICAgdHlwZSA9IHtcbiAgICAgICAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgICAgICAgbnVtYmVyOiAnbnVtYmVyJ1xuICAgICAgfTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoaXNOYU4oK2FycltpXSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXVzZXJjb25maWcucmFuZ2UgfHwgIXVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldKSB7XG4gICAgICByZXR1cm4gdHlwZS5zdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLm51bWJlcjtcbiAgfVxufVxud2luZG93LkZDRGF0YUZpbHRlckV4dCA9IEZDRGF0YUZpbHRlckV4dDtcblxuJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBGaWx0ZXJWaXN1YWwge1xuXG4gIGNvbnN0cnVjdG9yIChmaWx0ZXJTdGF0ZSwgY29udGFpbmVySWQsIGZpbHRlckV4dCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5maWx0ZXJTdGF0ZSA9IGZpbHRlclN0YXRlO1xuICAgIHRoaXMub3JpZ2luYWxGaWx0ZXJTdGF0ZSA9IHRoaXMubWFrZUNvcHkoZmlsdGVyU3RhdGUpO1xuICAgIHRoaXMuZmlsdGVyRXh0ID0gZmlsdGVyRXh0O1xuICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgdGhpcy5jb25maWcuY29udGFpbmVySWQgPSBjb250YWluZXJJZDtcbiAgICB0aGlzLmRyYXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBNYWtlIGNvcHkgb2YgYXJyYXkgb2YgT2JqZWN0c1xuICAgKi9cbiAgbWFrZUNvcHkgKGFycmF5T2ZPYmplY3RzKSB7XG4gICAgdmFyIGksXG4gICAgICBjb3B5ID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXlPZk9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcHkucHVzaChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFycmF5T2ZPYmplY3RzW2ldKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDcmVhdGUgRE9NIGVsZW1lbnRzIGFuZCBzZXQgYXR0cmlidXRlc1xuICAgKi9cbiAgY3JlYXRlRWxlbWVudHMgKG5hbWUsIGF0dHIpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSksXG4gICAgICBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBhdHRyKSB7XG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIGF0dHJba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ3JlYXRlIHJhbmdlIHNsaWRlciBjb21wb25lbnRcbiAgICovXG4gIGNyZWF0ZVNsaWRlciAocGFyZW50RWxlbWVudCwgZGF0YU9iaikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHNsaWRlcldyYXBwZXIsXG4gICAgICBpbnB1dFdyYXBwZXIsXG4gICAgICBtaW5JbnB1dCxcbiAgICAgIG1heElucHV0LFxuICAgICAgc2xpZGVyQmFzZSxcbiAgICAgIHNsaWRlckNvbm5lY3QsXG4gICAgICBtaW5TbGlkZXJIYW5kbGUsXG4gICAgICBtYXhTbGlkZXJIYW5kbGUsXG4gICAgICByYW5nZSA9IGRhdGFPYmoucmFuZ2UsXG4gICAgICBtaW5WYWwgPSByYW5nZVswXSxcbiAgICAgIG1heFZhbCA9IHJhbmdlWzFdLFxuICAgICAgZGlmZlZhbCA9IG1heFZhbCAtIG1pblZhbCxcbiAgICAgIGdldElucHV0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzbGlkZXJCYXNlV2lkdGggPSBzbGlkZXJCYXNlLm9mZnNldFdpZHRoLFxuICAgICAgICAgIHZhbHVlUGVyUGl4ZWwgPSBkaWZmVmFsIC8gc2xpZGVyQmFzZVdpZHRoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pbjogTWF0aC5yb3VuZCgodmFsdWVQZXJQaXhlbCAqIHBhcnNlSW50KG1pblNsaWRlckhhbmRsZS5zdHlsZS5sZWZ0KSkgKyBtaW5WYWwpLFxuICAgICAgICAgIG1heDogTWF0aC5yb3VuZCgodmFsdWVQZXJQaXhlbCAqIHBhcnNlSW50KG1heFNsaWRlckhhbmRsZS5zdHlsZS5sZWZ0KSkgKyBtaW5WYWwpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gQXR0YWNoIGV2ZW50cyB0byByYW5nZSBzbGlkZXIgaGFuZGxlc1xuICAgICAgYXR0YWNoSGFuZGxlckV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUpIHtcbiAgICAgICAgdmFyIGluaXRYLFxuICAgICAgICAgIG1vdXNlUHJlc3NYLFxuICAgICAgICAgIGZsYWcgPSB0cnVlLFxuICAgICAgICAgIHJhbmdlT2JqLFxuICAgICAgICAgIGNhbGxCYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVwb3NpdGlvbkVsZW1lbnQuY2FsbChlbGVtZW50LCBldmVudCk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIFNldCBzdHlsZSB0byBzbGlkZXIgaGFuZGxlIHRvIHJlcG9zaXRpb24gYWxvbmcgZHJhZ1xuICAgICAgICAgIHJlcG9zaXRpb25FbGVtZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgc2xpZGVyQmFzZVdpZHRoID0gc2xpZGVyQmFzZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlSW50KGluaXRYKSArIGV2ZW50LmNsaWVudFggLSBtb3VzZVByZXNzWCxcbiAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICBtYXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbWluJykge1xuICAgICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICAgICAgICBtYXggPSBwYXJzZUludChtYXhTbGlkZXJIYW5kbGUuc3R5bGUubGVmdCkgLSAxMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbiA9IHBhcnNlSW50KG1pblNsaWRlckhhbmRsZS5zdHlsZS5sZWZ0KSArIDEwO1xuICAgICAgICAgICAgICBtYXggPSBzbGlkZXJCYXNlV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZWZ0ID49IG1pbiAmJiBsZWZ0IDw9IG1heCkge1xuICAgICAgICAgICAgICBlbGVtLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaW4nKSB7XG4gICAgICAgICAgICAgICAgc2xpZGVyQ29ubmVjdC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2xpZGVyQ29ubmVjdC5zdHlsZS5yaWdodCA9IChzbGlkZXJCYXNlV2lkdGggLSBsZWZ0KSArICdweCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmFuZ2VPYmogPSBnZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICAgIGRhdGFPYmoucmFuZ2VbMF0gPSBtaW5JbnB1dC52YWx1ZSA9IHJhbmdlT2JqLm1pbjtcbiAgICAgICAgICAgICAgZGF0YU9iai5yYW5nZVsxXSA9IG1heElucHV0LnZhbHVlID0gcmFuZ2VPYmoubWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgfTtcblxuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldm50KSB7XG4gICAgICAgICAgdmFyIG1vdXNlVXBDYWxsQmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuYXBwbHlGaWx0ZXIoKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBjYWxsQmFjaywgZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwQ2FsbEJhY2ssIGZhbHNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGluaXRYID0gZWxlbS5zdHlsZS5sZWZ0O1xuICAgICAgICAgIG1vdXNlUHJlc3NYID0gZXZudC5jbGllbnRYO1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBjYWxsQmFjaywgZmFsc2UpO1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcENhbGxCYWNrLCBmYWxzZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIEF0dGFjaCBldmVudCB0byBtaW4gbWF4IGlucHV0IHRleHQgZmllbGQgb2YgcmFuZ2Ugc2xpZGVyXG4gICAgICBhdHRhY2hJbnB1dEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUpIHtcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKGV2bnQpIHtcbiAgICAgICAgICB2YXIgc2xpZGVyQmFzZVdpZHRoID0gc2xpZGVyQmFzZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIHBpeGVsUGVyVmFsdWUgPSBzbGlkZXJCYXNlV2lkdGggLyBkaWZmVmFsLFxuICAgICAgICAgICAgbWluSW5wdXRWYWwgPSBOdW1iZXIobWluSW5wdXQudmFsdWUpLFxuICAgICAgICAgICAgbWF4SW5wdXRWYWwgPSBOdW1iZXIobWF4SW5wdXQudmFsdWUpLFxuICAgICAgICAgICAgdGVtcFZhbCxcbiAgICAgICAgICAgIHJhbmdlT2JqO1xuXG4gICAgICAgICAgaWYgKChtaW5JbnB1dFZhbCA+PSBtaW5WYWwpICYmIChtYXhJbnB1dFZhbCA8PSBtYXhWYWwpICYmIChtaW5JbnB1dFZhbCA8PSBtYXhJbnB1dFZhbCkpIHtcbiAgICAgICAgICAgIHNsaWRlckNvbm5lY3Quc3R5bGUubGVmdCA9IG1pblNsaWRlckhhbmRsZS5zdHlsZS5sZWZ0ID1cbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCgocGl4ZWxQZXJWYWx1ZSAqIChtaW5JbnB1dFZhbCAtIG1pblZhbCkpKSArICdweCc7XG4gICAgICAgICAgICB0ZW1wVmFsID0gTWF0aC5yb3VuZChwaXhlbFBlclZhbHVlICogKG1heElucHV0VmFsIC0gbWluVmFsKSk7XG4gICAgICAgICAgICBtYXhTbGlkZXJIYW5kbGUuc3R5bGUubGVmdCA9IHRlbXBWYWwgKyAncHgnO1xuICAgICAgICAgICAgc2xpZGVyQ29ubmVjdC5zdHlsZS5yaWdodCA9IChzbGlkZXJCYXNlV2lkdGggLSB0ZW1wVmFsKSArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlT2JqID0gZ2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgIGRhdGFPYmoucmFuZ2VbMF0gPSBtaW5JbnB1dC52YWx1ZSA9IHJhbmdlT2JqLm1pbjtcbiAgICAgICAgICBkYXRhT2JqLnJhbmdlWzFdID0gbWF4SW5wdXQudmFsdWUgPSByYW5nZU9iai5tYXg7XG4gICAgICAgICAgc2VsZi5hcHBseUZpbHRlcigpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIHNsaWRlciBlbGVtZW50c1xuICAgIHNsaWRlcldyYXBwZXIgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdkaXYnLCB7XG4gICAgICAnY2xhc3MnOiAnZmNfZXh0X2ZpbHRlcl9zbGlkZXJfd3JhcHBlcidcbiAgICB9KTtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHNsaWRlcldyYXBwZXIpO1xuXG4gICAgaW5wdXRXcmFwcGVyID0gc2VsZi5jcmVhdGVFbGVtZW50cygnZGl2Jywge1xuICAgICAgJ2NsYXNzJzogJ2ZjX2V4dF9maWx0ZXJfc2xpZGVyX2lucHV0J1xuICAgIH0pO1xuICAgIHNsaWRlcldyYXBwZXIuYXBwZW5kQ2hpbGQoaW5wdXRXcmFwcGVyKTtcblxuICAgIG1pbklucHV0ID0gc2VsZi5jcmVhdGVFbGVtZW50cygnaW5wdXQnLCB7XG4gICAgICAndHlwZSc6ICd0ZXh0JyxcbiAgICAgICd2YWx1ZSc6IG1pblZhbFxuICAgIH0pO1xuICAgIGlucHV0V3JhcHBlci5hcHBlbmRDaGlsZChtaW5JbnB1dCk7XG4gICAgYXR0YWNoSW5wdXRFdmVudChtaW5JbnB1dCwgJ21pbicpO1xuXG4gICAgbWF4SW5wdXQgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdpbnB1dCcsIHtcbiAgICAgICd0eXBlJzogJ3RleHQnLFxuICAgICAgJ3ZhbHVlJzogbWF4VmFsLFxuICAgICAgJ3N0eWxlJzogJ2Zsb2F0OiByaWdodDsnXG4gICAgfSk7XG4gICAgaW5wdXRXcmFwcGVyLmFwcGVuZENoaWxkKG1heElucHV0KTtcbiAgICBhdHRhY2hJbnB1dEV2ZW50KG1heElucHV0LCAnbWF4Jyk7XG5cbiAgICBzbGlkZXJCYXNlID0gc2VsZi5jcmVhdGVFbGVtZW50cygnZGl2Jywge1xuICAgICAgJ2NsYXNzJzogJ2ZjX2V4dF9maWx0ZXJfc2xpZGVyX2Jhc2UnXG4gICAgfSk7XG4gICAgc2xpZGVyV3JhcHBlci5hcHBlbmRDaGlsZChzbGlkZXJCYXNlKTtcblxuICAgIHNsaWRlckNvbm5lY3QgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdkaXYnLCB7XG4gICAgICAnY2xhc3MnOiAnZmNfZXh0X2ZpbHRlcl9zbGlkZXJfY29ubmVjdCcsXG4gICAgICAnc3R5bGUnOiAnbGVmdDogMHB4OyByaWdodDogMHB4OydcbiAgICB9KTtcbiAgICBzbGlkZXJCYXNlLmFwcGVuZENoaWxkKHNsaWRlckNvbm5lY3QpO1xuXG4gICAgbWluU2xpZGVySGFuZGxlID0gc2VsZi5jcmVhdGVFbGVtZW50cygnZGl2Jywge1xuICAgICAgJ2NsYXNzJzogJ2ZjX2V4dF9maWx0ZXJfc2xpZGVyX2hhbmRsZScsXG4gICAgICAnc3R5bGUnOiAnbGVmdDogMHB4OydcbiAgICB9KTtcbiAgICBzbGlkZXJCYXNlLmFwcGVuZENoaWxkKG1pblNsaWRlckhhbmRsZSk7XG4gICAgYXR0YWNoSGFuZGxlckV2ZW50KG1pblNsaWRlckhhbmRsZSwgJ21pbicpO1xuXG4gICAgbWF4U2xpZGVySGFuZGxlID0gc2VsZi5jcmVhdGVFbGVtZW50cygnZGl2Jywge1xuICAgICAgJ2NsYXNzJzogJ2ZjX2V4dF9maWx0ZXJfc2xpZGVyX2hhbmRsZScsXG4gICAgICAnc3R5bGUnOiAnbGVmdDonICsgc2xpZGVyQmFzZS5vZmZzZXRXaWR0aCArICdweCdcbiAgICB9KTtcbiAgICBzbGlkZXJCYXNlLmFwcGVuZENoaWxkKG1heFNsaWRlckhhbmRsZSk7XG4gICAgYXR0YWNoSGFuZGxlckV2ZW50KG1heFNsaWRlckhhbmRsZSwgJ21heCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIERyYXcgdGhlIGZpbHRlciBjb21wb25lbnRcbiAgICovXG4gIGRyYXcgKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZpbHRlclN0YXRlID0gc2VsZi5maWx0ZXJTdGF0ZSxcbiAgICAgIGNvbnRhaW5lcklkID0gc2VsZi5jb25maWcuY29udGFpbmVySWQsXG4gICAgICBwYXJlbnRDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCksXG4gICAgICB3cmFwcGVyLFxuICAgICAgc2VjdGlvbixcbiAgICAgIGNhcmRzLFxuICAgICAgaGVhZGVyLFxuICAgICAgbGFiZWwsXG4gICAgICBjYXJkQm9keSxcbiAgICAgIHVsLFxuICAgICAgbGksXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGJ1dHRvbjtcblxuICAgIGlmICghcGFyZW50Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyZW50Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgd3JhcHBlciA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ2RpdicsIHtcbiAgICAgICdjbGFzcyc6ICdmY19leHRfZmlsdGVyX2NvbnQnLFxuICAgICAgJ3N0eWxlJzogJ292ZXJmbG93LXk6IHNjcm9sbDsgb3ZlcmZsb3cteDogaGlkZGVuOydcbiAgICB9KTtcbiAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHBhcmVudENvbnRhaW5lci5zdHlsZS5oZWlnaHQ7XG4gICAgcGFyZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlclN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2F0T2JqID0gZmlsdGVyU3RhdGVbaV0sXG4gICAgICAgIGlucHV0LFxuICAgICAgICBjYXROYW1lID0gY2F0T2JqLmNhdGVnb3J5O1xuXG4gICAgICBpZiAoY2F0T2JqLnZpc2libGUpIHtcbiAgICAgICAgc2VjdGlvbiA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ3NlY3Rpb24nKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcblxuICAgICAgICBjYXJkcyA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ2RpdicsIHtcbiAgICAgICAgICAnY2xhc3MnOiAnZmNfZXh0X2ZpbHRlcl9jYXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChjYXJkcyk7XG5cbiAgICAgICAgaGVhZGVyID0gc2VsZi5jcmVhdGVFbGVtZW50cygnaGVhZGVyJyk7XG4gICAgICAgIGNhcmRzLmFwcGVuZENoaWxkKGhlYWRlcik7XG5cbiAgICAgICAgbGFiZWwgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdsYWJlbCcpO1xuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSBjYXROYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICAgICAgY2FyZEJvZHkgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdkaXYnLCB7XG4gICAgICAgICAgJ2NsYXNzJzogJ2ZjX2V4dF9maWx0ZXJfY2FyZC1ib2R5J1xuICAgICAgICB9KTtcbiAgICAgICAgY2FyZHMuYXBwZW5kQ2hpbGQoY2FyZEJvZHkpO1xuXG4gICAgICAgIGlmIChjYXRPYmoudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB1bCA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ3VsJyk7XG4gICAgICAgICAgY2FyZEJvZHkuYXBwZW5kQ2hpbGQodWwpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNhdE9iai5pdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IGl0ZW1PYmogPSBjYXRPYmouaXRlbXNbal0sXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBpdGVtVmFsID0gaXRlbU9iai52YWx1ZTtcblxuICAgICAgICAgICAgbGkgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdsaScpO1xuICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuXG4gICAgICAgICAgICBpbnB1dCA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAndHlwZSc6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICd2YWx1ZSc6IGl0ZW1WYWwsXG4gICAgICAgICAgICAgICdpZCc6ICdmY19leHRfZmlsdGVyX2l0ZW1fJyArIGl0ZW1WYWwsXG4gICAgICAgICAgICAgICdjaGVja2VkJzogaXRlbU9iai5jaGVja2VkLFxuICAgICAgICAgICAgICAnc3R5bGUnOiAnY3Vyc29yOiBwb2ludGVyOydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpdGVtT2JqLmNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuICAgICAgICAgICAgICBzZWxmLmFwcGx5RmlsdGVyKCk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGl0ZW1PYmouZWxlbSA9IGlucHV0O1xuICAgICAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSBpdGVtT2JqLmRpc2FibGVkO1xuICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgbGFiZWwgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdsYWJlbCcsIHtcbiAgICAgICAgICAgICAgJ2Zvcic6ICdmY19leHRfZmlsdGVyX2l0ZW1fJyArIGl0ZW1WYWwsXG4gICAgICAgICAgICAgICdzdHlsZSc6ICdjdXJzb3I6IHBvaW50ZXI7J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSBpdGVtVmFsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBsaS5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuY3JlYXRlU2xpZGVyKGNhcmRCb2R5LCBjYXRPYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlY3Rpb24gPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdzZWN0aW9uJyk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICBidXR0b24gPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdidXR0b24nKTtcbiAgICBidXR0b24uaW5uZXJIVE1MID0gJ1Jlc2V0JztcbiAgICBidXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZmlsdGVyU3RhdGUgPSBzZWxmLm1ha2VDb3B5KHNlbGYub3JpZ2luYWxGaWx0ZXJTdGF0ZSk7XG4gICAgICBzZWxmLmRyYXcoKTtcbiAgICAgIHNlbGYuYXBwbHlGaWx0ZXIoKTtcbiAgICB9O1xuICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICB3aW5kb3cuZmlsdGVyU3RhdGUgPSBmaWx0ZXJTdGF0ZTtcbiAgICB3aW5kb3cub3JpZ2luYWxGaWx0ZXJTdGF0ZSA9IHNlbGYub3JpZ2luYWxGaWx0ZXJTdGF0ZTtcbiAgfVxuXG4gIC8vIEFwcGx5IGZpbHRlciB0byB0aGUgRGF0YVxuICBhcHBseUZpbHRlciAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZmlsdGVyRXh0LmFwcGx5KHNlbGYuZmlsdGVyU3RhdGUpO1xuICB9XG59XG59KHRoaXMsIGRvY3VtZW50KSk7XG4iXSwiZmlsZSI6ImRhdGEtZmlsdGVyLWVzNi5taW4uanMifQ==
