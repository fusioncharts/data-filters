(function(window, document, undefined) {
"use strict";

class FCDataFilterExt {
  constructor (datastore, userconfig, id, cb) {
    /**
    * User configuration format
    * {
    *   blockedCategories: ['Product'],
    *   disabledCategories: ['Product'],
    *   disabledItems: {
    *     'Product' : ['Tea']
    *   },
    *   range: {
    *     year: {min: 2000, max: 2010}
    *   }
    * }
    */
    this.multiChart = new MultiCharting();
    this.datastore = datastore;
    this.callback = cb;
    this.userconfig = userconfig || {};
    this.displayConfig = this.createMenuConfigFromData();
    this.filterVisual = new FilterVisual(this.displayConfig, id, this);
    // data set
  }

  generateBlockList (_list) {
    var list = _list || [],
      i = 0,
      ii = list.length,
      key,
      includeAll = false,
      blockList = [],
      item = {},
      itemListArr = [],
      j = 0,
      jj = 0,
      min = 0,
      max = 0,
      subItem = {};
    for (i = 0; i < ii; ++i) {
      item = list[i];
      includeAll = false;
      // if config was disabled or not visible; skip
      if (item.disabled || !item.visible) {
        continue;
      }
      if (!item.checked) {
        includeAll = true;
      }
      // Operation for type string
      if (item.type === 'string') {
        for (j = 0, jj = item.items.length; j < jj; ++j) {
          subItem = item.items[j];
          if (!subItem.disabled && (includeAll || !subItem.checked)) {
            if (blockList.indexOf(item.category + subItem.value) === -1) {
              blockList.push(item.category + subItem.value);
            } // end if
          } // end if
        } // end for j
      } // end if
      // operation for type number
      if (item.type === 'number') {
        for (j = 0, jj = item.items.length; j < jj; ++j) {
          subItem = item.items[j];
          min = item.range[0];
          max = item.range[1];
          if (includeAll || subItem.value < min || subItem.value > max) {
            if (blockList.indexOf(item.category + subItem.value) === -1) {
              blockList.push(item.category + subItem.value);
            } // end if
          } // end if
        } // end for j
      } // end if
    } // end for i
    return blockList;
  } // end function

  /**
  * function that will be called after
  * apply has been clicked in ui
  */
  apply (config) {
    var dataprocessor = this.multiChart.createDataProcessor();
    dataprocessor.filter(this.createFilter(config));
    // Executing the callback function whenever filter is applied
    this.callback(this.datastore.getData(dataprocessor));
  }

  createFilter (_config) {
    var config = _config || this.displayConfig,
      blockList = this.generateBlockList(config);
    return function (object, index, array) {
      var key;
      for (key in object) {
        if (blockList.indexOf(key + object[key]) !== -1) {
          return;
        }
      }
      return object;
    };
  }

  /**
  * Create config menu according to which
  * view will be rendered.
  */
  createMenuConfigFromData () {
    var config = [],
      datastore = this.datastore,
      key = '',
      temp = {},
      tempArr = {},
      type = '',
      keysArr = datastore.getKeys(),
      i = 0,
      ii = 0;
    if (!datastore) {
      return;
    }
    // Iterating over unique keys
    for (i = 0, ii = keysArr.length; i < ii; ++i) {
      key = keysArr[i];
      temp = {
        category: key,
        disabled: false,
        checked: true,
        visible: true,
        enableCheck: false
      };
      this.__createItemsList__(temp);
      this.__applyUserConfig__(temp);
      config.push(temp);
    }
    return config;
  }

  __createItemsList__ (object) {
    var datastore = this.datastore,
      category = object.category,
      valuesArr = datastore.getUniqueValues(category),
      type = this.__getType__(valuesArr),
      min = 0,
      max = 0,
      i = 0,
      ii = 0;
    // setting type
    object.type = type;
    if (type === 'string') {
      // string will have items list
      object.items = [];
      for (i = 0, ii = valuesArr.length; i < ii; ++i) {
        object.items.push({
          value: valuesArr[i],
          disabled: false,
          checked: true
        });
      }
    } else if (type === 'number') {
      // numbers will have range and a value list
      object.items = [];
      for (i = 0, ii = valuesArr.length; i < ii; ++i) {
        object.items.push({
          value: valuesArr[i]
        });
      }
      min = Math.min.apply(null, valuesArr);
      max = Math.max.apply(null, valuesArr);
      if (this.userconfig.range && this.userconfig.range[category]) {
        if (this.userconfig.range[category].min && this.userconfig.range[category].min > min) {
          min = this.userconfig.range[category].min;
        }
        if (this.userconfig.range[category].max && this.userconfig.range[category].max < max) {
          max = this.userconfig.range[category].max;
        }
      }
      object.range = [min, max];
    }
  }

  __applyUserConfig__ (object) {
    var userconfig = this.userconfig,
      type = object.type,
      category = object.category,
      blockedCategories = userconfig.blockedCategories,
      disabledCategories = userconfig.disabledCategories,
      disabledItems = userconfig.disabledItems && userconfig.disabledItems[category],
      items = object.items || [],
      i = 0,
      ii = items.length;

    if (Array.isArray(blockedCategories) && blockedCategories.indexOf(category) !== -1) {
      object.visible = false;
    }
    if (Array.isArray(disabledCategories) && disabledCategories.indexOf(category) !== -1) {
      object.disabled = true;
    }

    if (Array.isArray(disabledItems)) {
      for (; i < ii; ++i) {
        if (disabledItems.indexOf(items[i].value) !== -1) {
          object.items[i].disabled = true;
        }
      }
    }
  }

  __getType__ (arr) {
    let i = arr.length,
      type = {
        string: 'string',
        number: 'number'
      };
    while (i--) {
      if (isNaN(+arr[i])) {
        return type.string;
      }
    }
    return type.number;
  }
}
window.FCDataFilterExt = FCDataFilterExt;

'use strict';

class FilterVisual {

  constructor (filterState, containerId, filterExt) {
    /**
     * @private
     */
    this.filterState = filterState;
    this.filterExt = filterExt;
    this.config = {};
    this.config.containerId = containerId;
    this.draw();
  }

  draw () {
    var self = this,
      filterState = self.filterState,
      containerId = self.config.containerId,
      parentContainer = document.getElementById(containerId),
      wrapper,
      section,
      cards,
      header,
      input,
      label,
      cardBody,
      ul,
      li,
      i,
      j,
      catName,
      catObj,
      itemObj,
      itemVal,
      button;

    if (!parentContainer) {
      return;
    }

    parentContainer.innerHTML = '';

    wrapper = self.createElements('div', {
      'class': 'fc_ext_filter_cont'
    });
    wrapper.setAttribute('style', 'overflow-y: scroll; overflow-x: hidden;');
    wrapper.style.height = parentContainer.style.height;

    for (i = 0; i < filterState.length; i++) {
      catObj = filterState[i];
      catName = catObj.category;

      if (catObj.visible) {
        section = self.createElements('section');
        wrapper.appendChild(section);

        cards = self.createElements('div', {
          'class': 'fc_ext_filter_card'
        });
        section.appendChild(cards);

        header = self.createElements('header');
        cards.appendChild(header);

        input = self.createElements('input', {
          'type': 'checkbox',
          'value': catName,
          'id': 'fc_ext_filter_cat_' + catName,
          'checked': catObj.checked
        });
        catObj.elem = input;
        input.disabled = catObj.disabled;
        header.appendChild(input);

        label = self.createElements('label', {
          'for': 'fc_ext_filter_cat_' + catName
        });
        label.innerHTML = catName.toUpperCase();
        header.appendChild(label);

        cardBody = self.createElements('div', {
          'class': 'fc_ext_filter_card-body'
        });
        cards.appendChild(cardBody);

        if (catObj.type === 'string') {
          ul = self.createElements('ul');
          cardBody.appendChild(ul);

          for (j = 0; j < catObj.items.length; j++) {
            itemObj = catObj.items[j];
            itemVal = itemObj.value;

            li = self.createElements('li');
            ul.appendChild(li);

            input = self.createElements('input', {
              'type': 'checkbox',
              'value': itemVal,
              'id': 'fc_ext_filter_item_' + itemVal,
              'checked': itemObj.checked
            });
            itemObj.elem = input;
            input.disabled = itemObj.disabled;
            li.appendChild(input);
            label = self.createElements('label', {
              'for': 'fc_ext_filter_item_' + itemVal
            });
            label.innerHTML = itemVal.toUpperCase();
            li.appendChild(label);
          }
        }
      }
    }
    section = self.createElements('section');
    wrapper.appendChild(section);
    button = self.createElements('button');
    button.innerHTML = 'Apply';
    button.onclick = self.applyFilter.bind(this);
    section.appendChild(button);

    parentContainer.appendChild(wrapper);
    window.filterState = filterState;
  }

  applyFilter () {
    var self = this,
      filterState = self.filterState,
      i,
      j,
      catObj,
      itemObj,
      catElem,
      itemElem;

    for (i = 0; i < filterState.length; i++) {
      catObj = filterState[i];
      catElem = catObj.elem;

      if (catObj.type === 'string') {
        if (catElem && !catObj.disabled) {
          catObj.checked = catElem.checked;
        }
        for (j = 0; j < catObj.items.length; j++) {
          itemObj = catObj.items[j];
          itemElem = itemObj.elem;
          if (itemElem && !itemObj.disabled) {
            itemObj.checked = itemElem.checked;
          }
        }
      }
    }
    self.filterExt.apply(filterState);
  }

  createElements (name, attr) {
    var elem = document.createElement(name),
      key;

    for (key in attr) {
      elem.setAttribute(key, attr[key]);
    }

    return elem;
  }
}
}(this, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJkYXRhLWZpbHRlci1lczYubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblwidXNlIHN0cmljdFwiO1xuXG5jbGFzcyBGQ0RhdGFGaWx0ZXJFeHQge1xuICBjb25zdHJ1Y3RvciAoZGF0YXN0b3JlLCB1c2VyY29uZmlnLCBpZCwgY2IpIHtcbiAgICAvKipcbiAgICAqIFVzZXIgY29uZmlndXJhdGlvbiBmb3JtYXRcbiAgICAqIHtcbiAgICAqICAgYmxvY2tlZENhdGVnb3JpZXM6IFsnUHJvZHVjdCddLFxuICAgICogICBkaXNhYmxlZENhdGVnb3JpZXM6IFsnUHJvZHVjdCddLFxuICAgICogICBkaXNhYmxlZEl0ZW1zOiB7XG4gICAgKiAgICAgJ1Byb2R1Y3QnIDogWydUZWEnXVxuICAgICogICB9LFxuICAgICogICByYW5nZToge1xuICAgICogICAgIHllYXI6IHttaW46IDIwMDAsIG1heDogMjAxMH1cbiAgICAqICAgfVxuICAgICogfVxuICAgICovXG4gICAgdGhpcy5tdWx0aUNoYXJ0ID0gbmV3IE11bHRpQ2hhcnRpbmcoKTtcbiAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gICAgdGhpcy51c2VyY29uZmlnID0gdXNlcmNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmRpc3BsYXlDb25maWcgPSB0aGlzLmNyZWF0ZU1lbnVDb25maWdGcm9tRGF0YSgpO1xuICAgIHRoaXMuZmlsdGVyVmlzdWFsID0gbmV3IEZpbHRlclZpc3VhbCh0aGlzLmRpc3BsYXlDb25maWcsIGlkLCB0aGlzKTtcbiAgICAvLyBkYXRhIHNldFxuICB9XG5cbiAgZ2VuZXJhdGVCbG9ja0xpc3QgKF9saXN0KSB7XG4gICAgdmFyIGxpc3QgPSBfbGlzdCB8fCBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSBsaXN0Lmxlbmd0aCxcbiAgICAgIGtleSxcbiAgICAgIGluY2x1ZGVBbGwgPSBmYWxzZSxcbiAgICAgIGJsb2NrTGlzdCA9IFtdLFxuICAgICAgaXRlbSA9IHt9LFxuICAgICAgaXRlbUxpc3RBcnIgPSBbXSxcbiAgICAgIGogPSAwLFxuICAgICAgamogPSAwLFxuICAgICAgbWluID0gMCxcbiAgICAgIG1heCA9IDAsXG4gICAgICBzdWJJdGVtID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgaW5jbHVkZUFsbCA9IGZhbHNlO1xuICAgICAgLy8gaWYgY29uZmlnIHdhcyBkaXNhYmxlZCBvciBub3QgdmlzaWJsZTsgc2tpcFxuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQgfHwgIWl0ZW0udmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbS5jaGVja2VkKSB7XG4gICAgICAgIGluY2x1ZGVBbGwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gT3BlcmF0aW9uIGZvciB0eXBlIHN0cmluZ1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBpdGVtLml0ZW1zLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBzdWJJdGVtID0gaXRlbS5pdGVtc1tqXTtcbiAgICAgICAgICBpZiAoIXN1Ykl0ZW0uZGlzYWJsZWQgJiYgKGluY2x1ZGVBbGwgfHwgIXN1Ykl0ZW0uY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIGlmIChibG9ja0xpc3QuaW5kZXhPZihpdGVtLmNhdGVnb3J5ICsgc3ViSXRlbS52YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGJsb2NrTGlzdC5wdXNoKGl0ZW0uY2F0ZWdvcnkgKyBzdWJJdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH0gLy8gZW5kIGlmXG4gICAgICAgICAgfSAvLyBlbmQgaWZcbiAgICAgICAgfSAvLyBlbmQgZm9yIGpcbiAgICAgIH0gLy8gZW5kIGlmXG4gICAgICAvLyBvcGVyYXRpb24gZm9yIHR5cGUgbnVtYmVyXG4gICAgICBpZiAoaXRlbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGl0ZW0uaXRlbXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIHN1Ykl0ZW0gPSBpdGVtLml0ZW1zW2pdO1xuICAgICAgICAgIG1pbiA9IGl0ZW0ucmFuZ2VbMF07XG4gICAgICAgICAgbWF4ID0gaXRlbS5yYW5nZVsxXTtcbiAgICAgICAgICBpZiAoaW5jbHVkZUFsbCB8fCBzdWJJdGVtLnZhbHVlIDwgbWluIHx8IHN1Ykl0ZW0udmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIGlmIChibG9ja0xpc3QuaW5kZXhPZihpdGVtLmNhdGVnb3J5ICsgc3ViSXRlbS52YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGJsb2NrTGlzdC5wdXNoKGl0ZW0uY2F0ZWdvcnkgKyBzdWJJdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH0gLy8gZW5kIGlmXG4gICAgICAgICAgfSAvLyBlbmQgaWZcbiAgICAgICAgfSAvLyBlbmQgZm9yIGpcbiAgICAgIH0gLy8gZW5kIGlmXG4gICAgfSAvLyBlbmQgZm9yIGlcbiAgICByZXR1cm4gYmxvY2tMaXN0O1xuICB9IC8vIGVuZCBmdW5jdGlvblxuXG4gIC8qKlxuICAqIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXJcbiAgKiBhcHBseSBoYXMgYmVlbiBjbGlja2VkIGluIHVpXG4gICovXG4gIGFwcGx5IChjb25maWcpIHtcbiAgICB2YXIgZGF0YXByb2Nlc3NvciA9IHRoaXMubXVsdGlDaGFydC5jcmVhdGVEYXRhUHJvY2Vzc29yKCk7XG4gICAgZGF0YXByb2Nlc3Nvci5maWx0ZXIodGhpcy5jcmVhdGVGaWx0ZXIoY29uZmlnKSk7XG4gICAgLy8gRXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuZXZlciBmaWx0ZXIgaXMgYXBwbGllZFxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5kYXRhc3RvcmUuZ2V0RGF0YShkYXRhcHJvY2Vzc29yKSk7XG4gIH1cblxuICBjcmVhdGVGaWx0ZXIgKF9jb25maWcpIHtcbiAgICB2YXIgY29uZmlnID0gX2NvbmZpZyB8fCB0aGlzLmRpc3BsYXlDb25maWcsXG4gICAgICBibG9ja0xpc3QgPSB0aGlzLmdlbmVyYXRlQmxvY2tMaXN0KGNvbmZpZyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCBhcnJheSkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoYmxvY2tMaXN0LmluZGV4T2Yoa2V5ICsgb2JqZWN0W2tleV0pICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGNvbmZpZyBtZW51IGFjY29yZGluZyB0byB3aGljaFxuICAqIHZpZXcgd2lsbCBiZSByZW5kZXJlZC5cbiAgKi9cbiAgY3JlYXRlTWVudUNvbmZpZ0Zyb21EYXRhICgpIHtcbiAgICB2YXIgY29uZmlnID0gW10sXG4gICAgICBkYXRhc3RvcmUgPSB0aGlzLmRhdGFzdG9yZSxcbiAgICAgIGtleSA9ICcnLFxuICAgICAgdGVtcCA9IHt9LFxuICAgICAgdGVtcEFyciA9IHt9LFxuICAgICAgdHlwZSA9ICcnLFxuICAgICAga2V5c0FyciA9IGRhdGFzdG9yZS5nZXRLZXlzKCksXG4gICAgICBpID0gMCxcbiAgICAgIGlpID0gMDtcbiAgICBpZiAoIWRhdGFzdG9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJdGVyYXRpbmcgb3ZlciB1bmlxdWUga2V5c1xuICAgIGZvciAoaSA9IDAsIGlpID0ga2V5c0Fyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzQXJyW2ldO1xuICAgICAgdGVtcCA9IHtcbiAgICAgICAgY2F0ZWdvcnk6IGtleSxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjaGVja2VkOiB0cnVlLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBlbmFibGVDaGVjazogZmFsc2VcbiAgICAgIH07XG4gICAgICB0aGlzLl9fY3JlYXRlSXRlbXNMaXN0X18odGVtcCk7XG4gICAgICB0aGlzLl9fYXBwbHlVc2VyQ29uZmlnX18odGVtcCk7XG4gICAgICBjb25maWcucHVzaCh0ZW1wKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIF9fY3JlYXRlSXRlbXNMaXN0X18gKG9iamVjdCkge1xuICAgIHZhciBkYXRhc3RvcmUgPSB0aGlzLmRhdGFzdG9yZSxcbiAgICAgIGNhdGVnb3J5ID0gb2JqZWN0LmNhdGVnb3J5LFxuICAgICAgdmFsdWVzQXJyID0gZGF0YXN0b3JlLmdldFVuaXF1ZVZhbHVlcyhjYXRlZ29yeSksXG4gICAgICB0eXBlID0gdGhpcy5fX2dldFR5cGVfXyh2YWx1ZXNBcnIpLFxuICAgICAgbWluID0gMCxcbiAgICAgIG1heCA9IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGlpID0gMDtcbiAgICAvLyBzZXR0aW5nIHR5cGVcbiAgICBvYmplY3QudHlwZSA9IHR5cGU7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBzdHJpbmcgd2lsbCBoYXZlIGl0ZW1zIGxpc3RcbiAgICAgIG9iamVjdC5pdGVtcyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSB2YWx1ZXNBcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBvYmplY3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlc0FycltpXSxcbiAgICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgY2hlY2tlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBudW1iZXJzIHdpbGwgaGF2ZSByYW5nZSBhbmQgYSB2YWx1ZSBsaXN0XG4gICAgICBvYmplY3QuaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gdmFsdWVzQXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgb2JqZWN0Lml0ZW1zLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZXNBcnJbaV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB2YWx1ZXNBcnIpO1xuICAgICAgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdmFsdWVzQXJyKTtcbiAgICAgIGlmICh0aGlzLnVzZXJjb25maWcucmFuZ2UgJiYgdGhpcy51c2VyY29uZmlnLnJhbmdlW2NhdGVnb3J5XSkge1xuICAgICAgICBpZiAodGhpcy51c2VyY29uZmlnLnJhbmdlW2NhdGVnb3J5XS5taW4gJiYgdGhpcy51c2VyY29uZmlnLnJhbmdlW2NhdGVnb3J5XS5taW4gPiBtaW4pIHtcbiAgICAgICAgICBtaW4gPSB0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldLm1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VyY29uZmlnLnJhbmdlW2NhdGVnb3J5XS5tYXggJiYgdGhpcy51c2VyY29uZmlnLnJhbmdlW2NhdGVnb3J5XS5tYXggPCBtYXgpIHtcbiAgICAgICAgICBtYXggPSB0aGlzLnVzZXJjb25maWcucmFuZ2VbY2F0ZWdvcnldLm1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0LnJhbmdlID0gW21pbiwgbWF4XTtcbiAgICB9XG4gIH1cblxuICBfX2FwcGx5VXNlckNvbmZpZ19fIChvYmplY3QpIHtcbiAgICB2YXIgdXNlcmNvbmZpZyA9IHRoaXMudXNlcmNvbmZpZyxcbiAgICAgIHR5cGUgPSBvYmplY3QudHlwZSxcbiAgICAgIGNhdGVnb3J5ID0gb2JqZWN0LmNhdGVnb3J5LFxuICAgICAgYmxvY2tlZENhdGVnb3JpZXMgPSB1c2VyY29uZmlnLmJsb2NrZWRDYXRlZ29yaWVzLFxuICAgICAgZGlzYWJsZWRDYXRlZ29yaWVzID0gdXNlcmNvbmZpZy5kaXNhYmxlZENhdGVnb3JpZXMsXG4gICAgICBkaXNhYmxlZEl0ZW1zID0gdXNlcmNvbmZpZy5kaXNhYmxlZEl0ZW1zICYmIHVzZXJjb25maWcuZGlzYWJsZWRJdGVtc1tjYXRlZ29yeV0sXG4gICAgICBpdGVtcyA9IG9iamVjdC5pdGVtcyB8fCBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9ja2VkQ2F0ZWdvcmllcykgJiYgYmxvY2tlZENhdGVnb3JpZXMuaW5kZXhPZihjYXRlZ29yeSkgIT09IC0xKSB7XG4gICAgICBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNhYmxlZENhdGVnb3JpZXMpICYmIGRpc2FibGVkQ2F0ZWdvcmllcy5pbmRleE9mKGNhdGVnb3J5KSAhPT0gLTEpIHtcbiAgICAgIG9iamVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGlzYWJsZWRJdGVtcykpIHtcbiAgICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAoZGlzYWJsZWRJdGVtcy5pbmRleE9mKGl0ZW1zW2ldLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICBvYmplY3QuaXRlbXNbaV0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX19nZXRUeXBlX18gKGFycikge1xuICAgIGxldCBpID0gYXJyLmxlbmd0aCxcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgIHN0cmluZzogJ3N0cmluZycsXG4gICAgICAgIG51bWJlcjogJ251bWJlcidcbiAgICAgIH07XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzTmFOKCthcnJbaV0pKSB7XG4gICAgICAgIHJldHVybiB0eXBlLnN0cmluZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGUubnVtYmVyO1xuICB9XG59XG53aW5kb3cuRkNEYXRhRmlsdGVyRXh0ID0gRkNEYXRhRmlsdGVyRXh0O1xuXG4ndXNlIHN0cmljdCc7XG5cbmNsYXNzIEZpbHRlclZpc3VhbCB7XG5cbiAgY29uc3RydWN0b3IgKGZpbHRlclN0YXRlLCBjb250YWluZXJJZCwgZmlsdGVyRXh0KSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlclN0YXRlID0gZmlsdGVyU3RhdGU7XG4gICAgdGhpcy5maWx0ZXJFeHQgPSBmaWx0ZXJFeHQ7XG4gICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICB0aGlzLmNvbmZpZy5jb250YWluZXJJZCA9IGNvbnRhaW5lcklkO1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgZHJhdyAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgZmlsdGVyU3RhdGUgPSBzZWxmLmZpbHRlclN0YXRlLFxuICAgICAgY29udGFpbmVySWQgPSBzZWxmLmNvbmZpZy5jb250YWluZXJJZCxcbiAgICAgIHBhcmVudENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcklkKSxcbiAgICAgIHdyYXBwZXIsXG4gICAgICBzZWN0aW9uLFxuICAgICAgY2FyZHMsXG4gICAgICBoZWFkZXIsXG4gICAgICBpbnB1dCxcbiAgICAgIGxhYmVsLFxuICAgICAgY2FyZEJvZHksXG4gICAgICB1bCxcbiAgICAgIGxpLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBjYXROYW1lLFxuICAgICAgY2F0T2JqLFxuICAgICAgaXRlbU9iaixcbiAgICAgIGl0ZW1WYWwsXG4gICAgICBidXR0b247XG5cbiAgICBpZiAoIXBhcmVudENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcmVudENvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblxuICAgIHdyYXBwZXIgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdkaXYnLCB7XG4gICAgICAnY2xhc3MnOiAnZmNfZXh0X2ZpbHRlcl9jb250J1xuICAgIH0pO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdvdmVyZmxvdy15OiBzY3JvbGw7IG92ZXJmbG93LXg6IGhpZGRlbjsnKTtcbiAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHBhcmVudENvbnRhaW5lci5zdHlsZS5oZWlnaHQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVyU3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhdE9iaiA9IGZpbHRlclN0YXRlW2ldO1xuICAgICAgY2F0TmFtZSA9IGNhdE9iai5jYXRlZ29yeTtcblxuICAgICAgaWYgKGNhdE9iai52aXNpYmxlKSB7XG4gICAgICAgIHNlY3Rpb24gPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdzZWN0aW9uJyk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG5cbiAgICAgICAgY2FyZHMgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdkaXYnLCB7XG4gICAgICAgICAgJ2NsYXNzJzogJ2ZjX2V4dF9maWx0ZXJfY2FyZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoY2FyZHMpO1xuXG4gICAgICAgIGhlYWRlciA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ2hlYWRlcicpO1xuICAgICAgICBjYXJkcy5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG4gICAgICAgIGlucHV0ID0gc2VsZi5jcmVhdGVFbGVtZW50cygnaW5wdXQnLCB7XG4gICAgICAgICAgJ3R5cGUnOiAnY2hlY2tib3gnLFxuICAgICAgICAgICd2YWx1ZSc6IGNhdE5hbWUsXG4gICAgICAgICAgJ2lkJzogJ2ZjX2V4dF9maWx0ZXJfY2F0XycgKyBjYXROYW1lLFxuICAgICAgICAgICdjaGVja2VkJzogY2F0T2JqLmNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNhdE9iai5lbGVtID0gaW5wdXQ7XG4gICAgICAgIGlucHV0LmRpc2FibGVkID0gY2F0T2JqLmRpc2FibGVkO1xuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgIGxhYmVsID0gc2VsZi5jcmVhdGVFbGVtZW50cygnbGFiZWwnLCB7XG4gICAgICAgICAgJ2Zvcic6ICdmY19leHRfZmlsdGVyX2NhdF8nICsgY2F0TmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gY2F0TmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgICAgIGNhcmRCb2R5ID0gc2VsZi5jcmVhdGVFbGVtZW50cygnZGl2Jywge1xuICAgICAgICAgICdjbGFzcyc6ICdmY19leHRfZmlsdGVyX2NhcmQtYm9keSdcbiAgICAgICAgfSk7XG4gICAgICAgIGNhcmRzLmFwcGVuZENoaWxkKGNhcmRCb2R5KTtcblxuICAgICAgICBpZiAoY2F0T2JqLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdWwgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCd1bCcpO1xuICAgICAgICAgIGNhcmRCb2R5LmFwcGVuZENoaWxkKHVsKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjYXRPYmouaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGl0ZW1PYmogPSBjYXRPYmouaXRlbXNbal07XG4gICAgICAgICAgICBpdGVtVmFsID0gaXRlbU9iai52YWx1ZTtcblxuICAgICAgICAgICAgbGkgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdsaScpO1xuICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuXG4gICAgICAgICAgICBpbnB1dCA9IHNlbGYuY3JlYXRlRWxlbWVudHMoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAndHlwZSc6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICd2YWx1ZSc6IGl0ZW1WYWwsXG4gICAgICAgICAgICAgICdpZCc6ICdmY19leHRfZmlsdGVyX2l0ZW1fJyArIGl0ZW1WYWwsXG4gICAgICAgICAgICAgICdjaGVja2VkJzogaXRlbU9iai5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZW1PYmouZWxlbSA9IGlucHV0O1xuICAgICAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSBpdGVtT2JqLmRpc2FibGVkO1xuICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgbGFiZWwgPSBzZWxmLmNyZWF0ZUVsZW1lbnRzKCdsYWJlbCcsIHtcbiAgICAgICAgICAgICAgJ2Zvcic6ICdmY19leHRfZmlsdGVyX2l0ZW1fJyArIGl0ZW1WYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gaXRlbVZhbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWN0aW9uID0gc2VsZi5jcmVhdGVFbGVtZW50cygnc2VjdGlvbicpO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG4gICAgYnV0dG9uID0gc2VsZi5jcmVhdGVFbGVtZW50cygnYnV0dG9uJyk7XG4gICAgYnV0dG9uLmlubmVySFRNTCA9ICdBcHBseSc7XG4gICAgYnV0dG9uLm9uY2xpY2sgPSBzZWxmLmFwcGx5RmlsdGVyLmJpbmQodGhpcyk7XG4gICAgc2VjdGlvbi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgcGFyZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgIHdpbmRvdy5maWx0ZXJTdGF0ZSA9IGZpbHRlclN0YXRlO1xuICB9XG5cbiAgYXBwbHlGaWx0ZXIgKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZpbHRlclN0YXRlID0gc2VsZi5maWx0ZXJTdGF0ZSxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgY2F0T2JqLFxuICAgICAgaXRlbU9iaixcbiAgICAgIGNhdEVsZW0sXG4gICAgICBpdGVtRWxlbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJTdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY2F0T2JqID0gZmlsdGVyU3RhdGVbaV07XG4gICAgICBjYXRFbGVtID0gY2F0T2JqLmVsZW07XG5cbiAgICAgIGlmIChjYXRPYmoudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNhdEVsZW0gJiYgIWNhdE9iai5kaXNhYmxlZCkge1xuICAgICAgICAgIGNhdE9iai5jaGVja2VkID0gY2F0RWxlbS5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjYXRPYmouaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpdGVtT2JqID0gY2F0T2JqLml0ZW1zW2pdO1xuICAgICAgICAgIGl0ZW1FbGVtID0gaXRlbU9iai5lbGVtO1xuICAgICAgICAgIGlmIChpdGVtRWxlbSAmJiAhaXRlbU9iai5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaXRlbU9iai5jaGVja2VkID0gaXRlbUVsZW0uY2hlY2tlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5maWx0ZXJFeHQuYXBwbHkoZmlsdGVyU3RhdGUpO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudHMgKG5hbWUsIGF0dHIpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSksXG4gICAgICBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBhdHRyKSB7XG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIGF0dHJba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cbn1cbn0odGhpcywgZG9jdW1lbnQpKTtcbiJdLCJmaWxlIjoiZGF0YS1maWx0ZXItZXM2Lm1pbi5qcyJ9
